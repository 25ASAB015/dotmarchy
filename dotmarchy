#!/usr/bin/env bash
# shellcheck shell=bash
# shfmt: -ln=bash

#==================================================
#    ▐▌      ▐▌                      ▐▌
#  ▟█▟▌ ▟█▙ ▐███ ▐█▙█▖ ▟██▖ █▟█▌ ▟██▖▐▙██▖▝█ █▌
# ▐▛ ▜▌▐▛ ▜▌ ▐▌  ▐▌█▐▌ ▘▄▟▌ █▘  ▐▛  ▘▐▛ ▐▌ █▖█
# ▐▌ ▐▌▐▌ ▐▌ ▐▌  ▐▌█▐▌▗█▀▜▌ █   ▐▌   ▐▌ ▐▌ ▐█▛
# ▝█▄█▌▝█▄█▘ ▐▙▄ ▐▌█▐▌▐▙▄█▌ █   ▝█▄▄▌▐▌ ▐▌  █▌
#  ▝▀▝▘ ▝▀▘   ▀▀ ▝▘▀▝▘ ▀▀▝▘ ▀    ▝▀▀ ▝▘ ▝▘  █
#                                          █▌
#   Autor   -   Roberto Flores
#   Repo    -   https://github.com/25ASAB015/dotmarchy
#   Última actualización - 21-sep-2025
#
#   dotmarchy - Script para instalar los dotfiles de Roberto Flores en
#   Arch linux / Omarchy linux
#
# 	Copyright (C) 2025 dotmarchy <25ASAB015@ujmd.edu.sv>
# 	Licenciado bajo GPL-3.0

# 	Índice rápido de secciones:
#  	1) Apariencia y opciones (colores, flags, rutas)
#  	2) Logging y utilidades (log, info, debug, tiempo)
#  	3) Encabezado visual (logo)
#  	4) Manejo de errores (log_error, trap)
#  	5) Utilidades internas (run, require_cmd, normalize_repo_url, is_installed)
#  	6) Interacción con usuario (welcome)
#  	7) Dependencias (chaotic repo, oficiales, chaotic, AUR)
#  	8) dotbare (configuración)
#  	9) Main (flujo principal)

# Uso rápido:
#   dotmarchy
#   dotmarchy [REPO_URL]
# Ejemplo:
#   dotmarchy https://github.com/yo/mis-dotfiles.git
#==================================================

# Modo estricto: fallar ante errores y tuberías rotas
set -Eeuo pipefail

#==================================================
# Apariencia (colores) y opciones
#==================================================

CRE=$(tput setaf 1) # Rojo
CYE=$(tput setaf 3) # Amarillo
CGR=$(tput setaf 2) # Verde
CBL=$(tput setaf 4) # Azul
BLD=$(tput bold)    # Negrita
CNC=$(tput sgr0)    # Restablecer colores

# Opciones por defecto
DRY_RUN=0
FORCE=0
VERBOSE=0
INSTALL_EXTRAS=0
REPO_URL="git@github.com:25asab015/dotfiles.git"
DOTBARE_DIR_DEFAULT="$HOME/.cfg"
DOTBARE_TREE_DEFAULT="$HOME"

# Constantes y rutas
ERROR_LOG="$HOME/.local/share/dotmarchy/install_errors.log" # Log de errores
mkdir -p "$(dirname "$ERROR_LOG")" 2>/dev/null || true      # Asegurar carpeta

#==================================================
# Logging y utilidades básicas
#==================================================

# Salida simple (aprovecha colores definidos más abajo)
log() {
	printf "%s\n" "$*"
}

info() {
	printf "%b%s%b\n" "${CBL}" "$*" "${CNC}"
}

warn() {
	printf "%b%s%b\n" "${CYE}${BLD}" "$*" "${CNC}"
}

step() {
	printf "%b»%b %s\n" "${BLD}${CBL}" "${CNC}" "$*"
}

# Mensajes de depuración controlados por VERBOSE
debug() {
	[ "${VERBOSE:-0}" -eq 1 ] && printf "%b… %s%b\n" "${BLD}" "$*" "${CNC}" || true
}

# Tiempo en milisegundos
now_ms() { date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)); }

# Formatear duración ms → legible
fmt_ms() {
	ms=${1:-0}
	if [ "$ms" -ge 1000 ]; then
		s=$((ms / 1000))
		t=$(((ms % 1000) / 100))
		printf "%d.%ds" "$s" "$t"
	else
		printf "%dms" "$ms"
	fi
}

#==================================================
# Logo
#==================================================
logo() {
	text="$1"
	printf "%b" "
   ▗▖                              ▗▖        
   ▐▌      ▐▌                      ▐▌        
 ▟█▟▌ ▟█▙ ▐███ ▐█▙█▖ ▟██▖ █▟█▌ ▟██▖▐▙██▖▝█ █▌
▐▛ ▜▌▐▛ ▜▌ ▐▌  ▐▌█▐▌ ▘▄▟▌ █▘  ▐▛  ▘▐▛ ▐▌ █▖█ 
▐▌ ▐▌▐▌ ▐▌ ▐▌  ▐▌█▐▌▗█▀▜▌ █   ▐▌   ▐▌ ▐▌ ▐█▛ 
▝█▄█▌▝█▄█▘ ▐▙▄ ▐▌█▐▌▐▙▄█▌ █   ▝█▄▄▌▐▌ ▐▌  █▌ 
 ▝▀▝▘ ▝▀▘   ▀▀ ▝▘▀▝▘ ▀▀▝▘ ▀    ▝▀▀ ▝▘ ▝▘  █  
                                         █▌  

   ${BLD}${CRE}[ ${CYE}${text} ${CRE}]${CNC}\n\n"
}

#==================================================
# Manejo de errores
#==================================================
log_error() {
	error_msg=$1
	timestamp=$(date +"%Y-%m-%d %H:%M:%S")

	printf "%s" "[${timestamp}] ERROR: ${error_msg}\n" >>"$ERROR_LOG"
	printf "%s%sERROR:%s %s\n" "${CRE}" "${BLD}" "${CNC}" "${error_msg}" >&2
}

# Handler de error y activación del trap
on_error() {
	exit_code=$?
	line=${BASH_LINENO[0]:-UNKNOWN}
	log_error "Fallo en la línea ${line}. Código: ${exit_code}"
	exit "$exit_code"
}
trap on_error ERR

#==================================================
# Verificaciones iniciales
#==================================================
initial_checks() {
	# Verificar que NO se ejecute como root
	if [ "$(id -u)" = 0 ]; then
		log_error "This script MUST NOT be run as root user."
		exit 1
	fi

	# Verificar que se ejecute desde $HOME (evita confusiones de ruta)
	if [ "$PWD" != "$HOME" ]; then
		log_error "The script must be executed from HOME directory."
		exit 1
	fi

	# Verificar conexión a internet (ping rápido a 8.8.8.8)
	if ! ping -q -c 1 -W 1 8.8.8.8 >/dev/null 2>&1; then
		log_error "No internet connection detected."
		exit 1
	fi

	# Verificar que el sistema es Arch/Manjaro (requiere pacman)
	if ! command -v pacman >/dev/null 2>&1; then
		log_error "Este script está pensado para Arch/Manjaro (requiere pacman)."
		exit 1
	fi
}

#==================================================
# Utilidades internas (helpers generales)
#==================================================

# Ejecuta un comando con descripción y cronometraje (respeta DRY_RUN)
run() {
	desc="$1"
	shift
	step "$desc"
	debug "Comando: $*"
	if [ "$DRY_RUN" -eq 1 ]; then
		log "   ↳ (dry-run) $*"
		return 0
	fi
	start=$(now_ms)
	"$@"
	end=$(now_ms)
	dur=$((end - start))
	log "   ↳ ✔ Hecho en $(fmt_ms "$dur")"
}

# Verifica que un comando exista; si falta, aborta con código 127
require_cmd() {
	name="$1"
	command -v "$name" >/dev/null 2>&1 || {
		log_error "No se encontró el comando requerido: $name"
		exit 127
	}
}

# Normaliza URL de repo a forma comparable (host/owner/repo)
normalize_repo_url() {
	# Entrada: URL (ssh o https); Salida: host/owner/repo en minúsculas, sin .git
	url="$1"
	url=${url%%.git}
	# ssh: git@github.com:owner/repo
	if [[ "$url" =~ ^git@([^:]+):(.+)$ ]]; then
		echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}" | tr '[:upper:]' '[:lower:]'
		return 0
	fi
	# https: https://github.com/owner/repo
	if [[ "$url" =~ ^https?://([^/]+)/(.+)$ ]]; then
		echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}" | tr '[:upper:]' '[:lower:]'
		return 0
	fi
	# Si ya es host/owner/repo
	echo "$url" | tr '[:upper:]' '[:lower:]'
}

# Convierte URL SSH a HTTPS
ssh_to_https() {
	url="$1"
	# ssh: git@github.com:owner/repo -> https://github.com/owner/repo
	if [[ "$url" =~ ^git@([^:]+):(.+)$ ]]; then
		host="${BASH_REMATCH[1]}"
		path="${BASH_REMATCH[2]}"
		# Si no termina en .git, agregarlo
		[[ "$path" =~ \.git$ ]] || path="${path}.git"
		echo "https://${host}/${path}"
		return 0
	fi
	# Si ya es HTTPS, devolverla tal cual
	echo "$url"
}

# Verifica si SSH está disponible para GitHub
check_ssh_auth() {
	# Intenta una conexión SSH a GitHub (timeout corto para no bloquear)
	# GitHub responde con "Hi username! You've successfully authenticated" si funciona
	# o "Permission denied" si no hay autenticación
	ssh_output=$(ssh -T -o ConnectTimeout=5 -o StrictHostKeyChecking=no git@github.com 2>&1)
	ssh_exit=$?
	
	# Si la salida contiene "successfully authenticated", SSH está configurado
	if echo "$ssh_output" | grep -qi "successfully authenticated"; then
		return 0
	fi
	
	# Si el código de salida es 1 y contiene "Permission denied", no hay autenticación
	if [ "$ssh_exit" -eq 1 ] && echo "$ssh_output" | grep -qi "permission denied\|publickey"; then
		return 1
	fi
	
	# Otros errores (timeout, red, etc.) - asumir que no hay SSH disponible
	return 1
}

#==================================================
# Argumentos CLI (parseo de flags)
#==================================================

# Muestra ayuda breve de uso
usage() {
	cat <<EOF
Uso: $(basename "$0") [opciones] [REPO_URL]

Opciones:
  --repo URL      Especifica el repositorio de dotfiles a usar
  --extras        Instala paquetes adicionales opcionales además de los core
  -h, --help      Muestra esta ayuda y sale

Posicional:
  REPO_URL        Alternativamente puedes pasar la URL del repo como primer argumento

Ejemplos:
  $(basename "$0") --repo https://github.com/yo/mis-dotfiles.git
  $(basename "$0") git@github.com:yo/mis-dotfiles.git
  $(basename "$0") --extras
EOF
}

# Parsea opciones de línea de comandos
parse_args() {
	while [ $# -gt 0 ]; do
		case "$1" in
		--repo)
			shift || true
			REPO_URL="${1:-$REPO_URL}"
			;;
		--extras)
			INSTALL_EXTRAS=1
			;;
		-h | --help)
			usage
			exit 0
			;;
		-*)
			log_error "Opción desconocida: $1"
			usage
			exit 2
			;;
		*)
			# Argumento posicional: URL del repo
			REPO_URL="$1"
			;;
		esac
		shift || true
	done
}

# Comprueba si un paquete está instalado vía pacman -Qq
is_installed() {
	pacman -Qq "$1" >/dev/null 2>&1
}

#==================================================
# Interacción con el usuario (bienvenida)
#==================================================

# Mensaje de bienvenida y confirmación de continuación
welcome() {
	clear
	logo "Bienvenido a dotmarchy, $USER"

	printf "%b" "${BLD}${CGR}Este script instalará y configurará tus dotfiles de forma segura y automatizada. ¿Qué hará exactamente?

  ${BLD}${CGR}[${CYE}i${CGR}]${CNC} Actualizará tu sistema con pacman -Syu
  ${BLD}${CGR}[${CYE}i${CGR}]${CNC} Añadirá el repositorio Chaotic-AUR para acelerar la instalación de paquetes AUR
  ${BLD}${CGR}[${CYE}i${CGR}]${CNC} Instalará todas las dependencias necesarias (oficiales, Chaotic y AUR)
  ${BLD}${CGR}[${CYE}i${CGR}]${CNC} Instalará y configurará dotbare para gestionar tus dotfiles
  ${BLD}${CGR}[${CYE}i${CGR}]${CNC} Realizará un respaldo automático de tus configuraciones previas antes de sobrescribirlas
  ${BLD}${CGR}[${CYE}i${CGR}]${CNC} Clonará y aplicará tu repositorio de dotfiles usando dotbare

${BLD}${CGR}[${CRE}!${CGR}]${CNC} ${BLD}${CRE}Este script NO modifica configuraciones críticas del sistema${CNC}
${BLD}${CGR}[${CRE}!${CGR}]${CNC} ${BLD}${CRE}Puedes restaurar tus configuraciones anteriores desde la carpeta de backup creada automáticamente${CNC}

"

	while :; do
		printf " %b" "${BLD}${CGR}¿Deseas continuar?${CNC} [s/N]: "
		read -r yn
		case "$yn" in
		[SsYy])
			break
			;;
		[Nn] | "")
			printf "\n%b\n" "${BLD}${CYE}Operación cancelada${CNC}"
			exit 0
			;;
		*)
			printf "\n%b\n" "${BLD}${CRE}Error:${CNC} Digita '${BLD}${CYE}s/y${CNC}' para sí o '${BLD}${CYE}n${CNC}' para no"
			;;
		esac
	done
}

#==================================================
# Dependencias (repositorios y paquetes)
#==================================================

# Añade el repositorio chaotic-aur (keyring, mirrorlist y entrada en pacman.conf)
add_chaotic_repo() {
	clear
	logo "Agregar el repositorio chaotic-aur"
	repo_name="chaotic-aur"
	key_id="3056513887B78AEB"
	sleep 2

	# Mensaje de configuración del repositorio
	printf "%b\n" "${BLD}${CYE}Instalando el repositorio ${CBL}${repo_name}${CYE}...${CNC}"

	# Verificar si ya existe la sección en pacman.conf
	if grep -q "\[${repo_name}\]" /etc/pacman.conf; then
		printf "%b\n" "\n${BLD}${CYE}El repositorio ya existe en pacman.conf${CNC}"
		sleep 3
		return 0
	fi

	# Gestión de clave GPG
	if ! pacman-key -l | grep -q "$key_id"; then
		printf "%b\n" "${BLD}${CYE}Agregando la llave GPG...${CNC}"
		if ! sudo pacman-key --recv-key "$key_id" --keyserver keyserver.ubuntu.com 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			log_error "Error al recibir la llave GPG"
			return 1
		fi

		printf "%b\n" "${BLD}${CYE}Firmando la llave GPG localmente...${CNC}"
		if ! sudo pacman-key --lsign-key "$key_id" 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			log_error "Error al firmar la llave GPG"
			return 1
		fi
	else
		printf "\n%b\n" "${BLD}${CYE}La llave GPG ya existe en el keyring${CNC}"
	fi

	# Instalación de paquetes requeridos
	chaotic_pkgs="chaotic-keyring chaotic-mirrorlist"
	for pkg in $chaotic_pkgs; do
		if ! pacman -Qq "$pkg" >/dev/null 2>&1; then
			printf "%b\n" "${BLD}${CYE}Instalando ${CBL}${pkg}${CNC}"
			if ! sudo pacman -U --noconfirm "https://cdn-mirror.chaotic.cx/chaotic-aur/${pkg}.pkg.tar.zst" 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
				log_error "Error al instalar ${pkg}"
				return 1
			fi
		else
			printf "%b\n" "${BLD}${CYE}${pkg} ya está instalado${CNC}"
		fi
	done

	# Agregar configuración del repositorio
	printf "\n%b\n" "${BLD}${CYE}Agregando el repositorio a pacman.conf...${CNC}"
	if ! printf "\n[%s]\nInclude = /etc/pacman.d/chaotic-mirrorlist\n" "$repo_name" |
		sudo tee -a /etc/pacman.conf >/dev/null 2>>"$ERROR_LOG"; then
		log_error "Error al agregar la configuración del repositorio"
		return 1
	fi

	printf "%b\n" "\n${BLD}${CBL}${repo_name} ${CGR}Repositorio configurado correctamente!${CNC}"
	sleep 3
}

#--------------------------------------------------
# Dependencias desde repos oficiales (pacman)
#--------------------------------------------------

install_dependencies() {
	clear
	logo "Instalando las dependencias necesarias desde los repositorios oficiales..."
	sleep 2

	# Verificar si reflector está instalado y actualizar el mirrorlist
	sudo pacman -Syy

	# Lista de dependencias (repos oficiales)
	dependencies="tree bat highlight ruby-coderay git-delta diff-so-fancy"
	
	# Paquetes opcionales adicionales (solo con --extras)
	extra_dependencies="neovim tmux htop ripgrep fd fzf"
	
	# Si --extras está activado, agregar paquetes extras
	if [ "$INSTALL_EXTRAS" -eq 1 ]; then
		dependencies="$dependencies $extra_dependencies"
		printf "\n%b\n" "${BLD}${CYE}[--extras] Incluyendo paquetes adicionales opcionales${CNC}"
	fi

	printf "\n%b\n\n" "${BLD}${CBL}Verificando las dependencias necesarias...${CNC}"
	sleep 2

	# Detectar paquetes faltantes
	missing_pkgs=""
	for pkg in $dependencies; do
		if ! is_installed "$pkg"; then
			missing_pkgs="$missing_pkgs $pkg"
			printf "%b\n" " ${BLD}${CYE}$pkg ${CRE}no instalado${CNC}"
		else
			printf "%b\n" "${BLD}${CGR}$pkg ${CBL}ya está instalado${CNC}"
		fi
	done

	# Instalación por lotes si es necesario
	if [ -n "$(printf "%s" "$missing_pkgs" | tr -s ' ')" ]; then
		count=$(printf "%s" "$missing_pkgs" | wc -w)
		printf "\n%b\n\n" "${BLD}${CYE}Instalando $count paquetes, por favor espera...${CNC}"

		if sudo pacman -S --noconfirm $missing_pkgs 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			# Verificar instalación completa
			failed_pkgs=""
			for pkg in $missing_pkgs; do
				if ! is_installed "$pkg"; then
					failed_pkgs="$failed_pkgs $pkg"
					log_error "Error al instalar: $pkg"
				fi
			done

			# Mostrar resultados finales
			if [ -z "$(printf "%s" "$failed_pkgs" | tr -s ' ')" ]; then
				printf "%b\n\n" "${BLD}${CGR}Todos los paquetes se han instalado correctamente!${CNC}"
			else
				fail_count=$(printf "%s" "$failed_pkgs" | wc -w)
				printf "%b\n" "${BLD}${CRE}Error al instalar $fail_count paquetes:${CNC}"
				printf "%b\n\n" "  ${BLD}${CYE}$(printf "%s" "$failed_pkgs")${CNC}"
			fi
		else
			log_error "Error crítico durante la instalación por lotes"
			printf "%b\n" "${BLD}${CRE}Error al instalar! Verifica el log para más detalles${CNC}"
			return 1
		fi
	else
		printf "%b\n" "\n${BLD}${CGR}Todas las dependencias ya están instaladas${CNC}"
	fi

	sleep 3
}

#--------------------------------------------------
# Dependencias desde chaotic (ej. paru)
#--------------------------------------------------

install_chaotic_dependencies() {
	clear
	logo "Instalando las dependencias necesarias desde el repositorio chaotic"
	sleep 2

	# Lista de dependencias (chaotic)
	chaotic_dependencies="paru"
	
	# Paquetes opcionales adicionales (solo con --extras)
	extra_chaotic_dependencies="brave-bin visual-studio-code-bin"
	
	# Si --extras está activado, agregar paquetes extras
	if [ "$INSTALL_EXTRAS" -eq 1 ]; then
		chaotic_dependencies="$chaotic_dependencies $extra_chaotic_dependencies"
		printf "\n%b\n" "${BLD}${CYE}[--extras] Incluyendo paquetes adicionales opcionales desde Chaotic-AUR${CNC}"
	fi

	printf "%b\n\n" "${BLD}${CBL}Verificando las dependencias necesarias...${CNC}"
	sleep 2

	# Detectar paquetes faltantes
	missing_chaotic_pkgs=""
	for pkg in $chaotic_dependencies; do
		if ! is_installed "$pkg"; then
			missing_chaotic_pkgs="$missing_chaotic_pkgs $pkg"
			printf "%b\n" " ${BLD}${CYE}$pkg ${CRE}no instalado${CNC}"
		else
			printf "%b\n" "${BLD}${CGR}$pkg ${CBL}ya está instalado${CNC}"
		fi
	done

	# Instalación por lotes si es necesario
	if [ -n "$(printf "%s" "$missing_chaotic_pkgs" | tr -s ' ')" ]; then
		count=$(printf "%s" "$missing_chaotic_pkgs" | wc -w)
		printf "\n%b\n\n" "${BLD}${CYE}Instalando $count paquetes, por favor espera...${CNC}"

		if sudo pacman -S --noconfirm $missing_chaotic_pkgs 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			# Verificar instalación completa
			failed_chaotic_pkgs=""
			for pkg in $missing_chaotic_pkgs; do
				if ! is_installed "$pkg"; then
					failed_chaotic_pkgs="$failed_chaotic_pkgs $pkg"
					log_error "Error al instalar: $pkg"
				fi
			done

			# Mostrar resultados finales
			if [ -z "$(printf "%s" "$failed_chaotic_pkgs" | tr -s ' ')" ]; then
				printf "%b\n\n" "${BLD}${CGR}Todos los paquetes se han instalado correctamente!${CNC}"
			else
				fail_count=$(printf "%s" "$failed_chaotic_pkgs" | wc -w)
				printf "%b\n" "${BLD}${CRE}Error al instalar $fail_count paquetes:${CNC}"
				printf "%b\n\n" "  ${BLD}${CYE}$(printf "%s" "$failed_chaotic_pkgs")${CNC}"
			fi
		else
			log_error "Error crítico durante la instalación por lotes"
			printf "%b\n" "${BLD}${CRE}Error al instalar Verifica el log para más detalles${CNC}"
			return 1
		fi
	else
		printf "\n%b\n" "${BLD}${CGR}Todas las dependencias ya están instaladas!${CNC}"
	fi

	sleep 3
}

#--------------------------------------------------
# Dependencias desde AUR (extras)
#--------------------------------------------------

install_aur_dependencies() {
	clear
	logo "Instalando las dependencias necesarias desde AUR..."
	sleep 2

	# Lista de paquetes AUR adicionales
	aur_apps="dotbare"
	
	# Paquetes opcionales adicionales (solo con --extras)
	extra_aur_apps="zsh-theme-powerlevel10k-git zsh-autosuggestions zsh-syntax-highlighting"
	
	# Si --extras está activado, agregar paquetes extras
	if [ "$INSTALL_EXTRAS" -eq 1 ]; then
		aur_apps="$aur_apps $extra_aur_apps"
		printf "\n%b\n" "${BLD}${CYE}[--extras] Incluyendo paquetes adicionales opcionales desde AUR${CNC}"
	fi

	printf "%b\n\n" "${BLD}${CBL}Verificando las dependencias necesarias...${CNC}"
	sleep 2

	# Detectar paquetes faltantes AUR
	missing_aur=""
	for pkg in $aur_apps; do
		if ! is_installed "$pkg"; then
			missing_aur="$missing_aur $pkg"
			printf "%b\n" " ${BLD}${CYE}$pkg ${CRE}no instalado${CNC}"
		else
			printf "%b\n" "${BLD}${CGR}$pkg ${CBL}ya está instalado${CNC}"
		fi
	done

	# Instalación por lotes AUR si es necesario
	if [ -n "$(printf "%s" "$missing_aur" | tr -s ' ')" ]; then
		count=$(printf "%s" "$missing_aur" | wc -w)
		printf "\n%b\n\n" "${BLD}${CYE}Instalando $count paquetes AUR, por favor espera...${CNC}"

		aur_failed=""
		for pkg in $missing_aur; do
			printf "%b\n" "${BLD}${CBL}Processing: ${pkg}${CNC}"

			if paru -S --skipreview --noconfirm "$pkg" >>"$ERROR_LOG" 2>&1; then
				printf "%b\n" "  ${BLD}${CGR}Se ha instalado correctamente!${CNC}"
			else
				log_error "Error al instalar el paquete AUR$pkg"
				aur_failed="$aur_failed $pkg"
				printf "%b\n" "  ${BLD}${CRE}Error al instalar${CNC}"
			fi
			sleep 0.5
		done

		# Mostrar resultados finales
		if [ -n "$(printf "%s" "$aur_failed" | tr -s ' ')" ]; then
			fail_count=$(printf "%s" "$aur_failed" | wc -w)
			printf "%b\n" "\n${BLD}${CRE}Error al instalar $fail_count/$count paquetes AUR:${CNC}"
			printf "%b\n\n" "${BLD}${CYE}$(printf "%s" "$aur_failed")${CNC}"
		else
			printf "\n%b\n\n" "${BLD}${CGR}Todos los paquetes AUR se han instalado correctamente!${CNC}"
		fi
	else
		printf "\n%b\n\n" "${BLD}${CGR}Todas las dependencias AUR ya están instaladas!${CNC}"
	fi

	sleep 3
}

#==================================================
# Configuración de dotbare (gestión de dotfiles)
#==================================================

# Configura dotbare (repo bare de dotfiles) y ajusta remoto si es necesario
configure_dotbare() {
	clear
	logo "Configurando dotbare"
	sleep 2

	printf "%b\n" "${BLD}${CBL}Preparando dotbare para gestionar tus dotfiles...${CNC}"
	sleep 1

	require_cmd dotbare

	# Permitir override por entorno
	DOTBARE_DIR="${DOTBARE_DIR:-$DOTBARE_DIR_DEFAULT}"
	DOTBARE_TREE="${DOTBARE_TREE:-$DOTBARE_TREE_DEFAULT}"
	export DOTBARE_DIR DOTBARE_TREE

	if [ -d "$DOTBARE_DIR" ]; then
		# Verificar remoto
		if git --git-dir="$DOTBARE_DIR" rev-parse --is-bare-repository >/dev/null 2>&1; then
			current=""
			target_nc=""
			current_nc=""
			current=$(git --git-dir="$DOTBARE_DIR" remote get-url origin 2>/dev/null || echo "")
			target_nc=$(normalize_repo_url "$REPO_URL")
			current_nc=$(normalize_repo_url "$current")
			if [ -n "$current" ] && [ "$current_nc" != "$target_nc" ]; then
				if [ "$FORCE" -eq 1 ]; then
					printf "%b\n" "${BLD}${CYE}Remoto distinto detectado (${CBL}$current${CYE}). Reemplazando por ${CBL}$REPO_URL${CYE} por --force${CNC}"
					if git --git-dir="$DOTBARE_DIR" remote set-url origin "$REPO_URL" 2>>"$ERROR_LOG"; then
						printf "%b\n" "${BLD}${CGR}Remoto actualizado correctamente!${CNC}"
					else
						log_error "Error al actualizar el remoto de dotbare"
						printf "%b\n" "${BLD}${CRE}Error al actualizar el remoto de dotbare${CNC}"
					fi
				else
					printf "%b\n" "${BLD}${CYE}Remoto existente distinto (${CBL}$current${CYE}). Se mantiene. Usa --force para cambiarlo.${CNC}"
				fi
			else
				printf "%b\n" "${BLD}${CGR}dotbare ya inicializado y remoto correcto.${CNC}"
			fi
		else
			printf "%b\n" "${BLD}${CRE}${DOTBARE_DIR} existe pero no parece un repo bare.${CNC}"
			if [ "$FORCE" -eq 1 ]; then
				printf "%b\n" "${BLD}${CYE}Moviendo directorio conflictivo a respaldo...${CNC}"
				if mv "$DOTBARE_DIR" "${DOTBARE_DIR}.bak_$(date +%s)" 2>>"$ERROR_LOG"; then
					printf "%b\n" "${BLD}${CGR}Respaldo realizado correctamente.${CNC}"
				else
					log_error "Error al respaldar el directorio conflictivo: $DOTBARE_DIR"
					printf "%b\n" "${BLD}${CRE}Error al respaldar el directorio conflictivo${CNC}"
					exit 1
				fi
			else
				printf "%b\n" "${BLD}${CRE}Directorio en conflicto. Usa --force para respaldar y continuar.${CNC}"
				exit 1
			fi
		fi
	fi

	if [ ! -d "$DOTBARE_DIR" ]; then
		printf "%b\n" "${BLD}${CBL}Inicializando dotbare con tu repositorio...${CNC}"
		
		# Determinar URL a usar (SSH o HTTPS)
		FINAL_REPO_URL="$REPO_URL"
		
		# Si la URL es SSH, verificar autenticación
		if [[ "$REPO_URL" =~ ^git@ ]]; then
			if ! check_ssh_auth; then
				# No hay autenticación SSH, convertir a HTTPS
				FINAL_REPO_URL=$(ssh_to_https "$REPO_URL")
				printf "%b\n" "${BLD}${CYE}SSH no disponible. Usando HTTPS: ${CBL}${FINAL_REPO_URL}${CNC}"
			else
				printf "%b\n" "${BLD}${CGR}Autenticación SSH detectada. Usando SSH.${CNC}"
			fi
		fi
		
		# Intentar inicializar con la URL determinada
		if dotbare finit -u "$FINAL_REPO_URL" 2>>"$ERROR_LOG"; then
			printf "%b\n" "${BLD}${CGR}dotbare inicializado correctamente!${CNC}"
		else
			# Si falló y era SSH, intentar con HTTPS como fallback
			if [[ "$REPO_URL" =~ ^git@ ]] && [ "$FINAL_REPO_URL" = "$REPO_URL" ]; then
				HTTPS_URL=$(ssh_to_https "$REPO_URL")
				printf "%b\n" "${BLD}${CYE}Falló con SSH. Intentando con HTTPS: ${CBL}${HTTPS_URL}${CNC}"
				if dotbare finit -u "$HTTPS_URL" 2>>"$ERROR_LOG"; then
					FINAL_REPO_URL="$HTTPS_URL"
					printf "%b\n" "${BLD}${CGR}dotbare inicializado correctamente con HTTPS!${CNC}"
				else
					log_error "Error al inicializar dotbare (intentó SSH y HTTPS)"
					printf "%b\n" "${BLD}${CRE}Error al inicializar dotbare${CNC}"
					printf "%b\n" "${BLD}${CYE}Verifica que el repositorio existe y es accesible.${CNC}"
					return 1
				fi
			else
				log_error "Error al inicializar dotbare"
				printf "%b\n" "${BLD}${CRE}Error al inicializar dotbare${CNC}"
				printf "%b\n" "${BLD}${CYE}Verifica que el repositorio existe y es accesible.${CNC}"
				return 1
			fi
		fi
	fi

	# Usar FINAL_REPO_URL si está definida, sino REPO_URL
	DISPLAY_URL="${FINAL_REPO_URL:-$REPO_URL}"
	printf "%b\n" "${BLD}${CGR}dotbare listo! (${CBL}${DOTBARE_DIR}${CGR} ↔ ${CBL}${DISPLAY_URL}${CGR})${CNC}"
	sleep 2
}

#==================================================
# Ejecución principal (orden del flujo)
#==================================================


main() {
	# Procesar flags y argumento posicional (REPO_URL)
	parse_args "$@" # Analiza los argumentos de línea de comandos y flags (como --force, --dry-run, etc.)
	initial_checks  # Realiza comprobaciones iniciales: no root, en $HOME, dependencias básicas, etc.
	welcome         # Muestra mensaje de bienvenida e información al usuario

	add_chaotic_repo             # Añade el repositorio Chaotic-AUR si es necesario (para instalar paquetes extra)
	install_dependencies         # Instala los paquetes requeridos desde los repositorios oficiales
	install_chaotic_dependencies # Instala dependencias específicas desde Chaotic-AUR
	install_aur_dependencies     # Instala paquetes desde AUR usando un helper (ej: paru)

	configure_dotbare # Inicializa y configura dotbare con el repositorio de dotfiles indicado
}

# Ejecuta el script
main "$@"
