#!/usr/bin/env bash
# shellcheck shell=bash
# shfmt: -ln=bash

#==================================================
#    ‚ñê‚ñå      ‚ñê‚ñå                      ‚ñê‚ñå
#  ‚ñü‚ñà‚ñü‚ñå ‚ñü‚ñà‚ñô ‚ñê‚ñà‚ñà‚ñà ‚ñê‚ñà‚ñô‚ñà‚ññ ‚ñü‚ñà‚ñà‚ññ ‚ñà‚ñü‚ñà‚ñå ‚ñü‚ñà‚ñà‚ññ‚ñê‚ñô‚ñà‚ñà‚ññ‚ñù‚ñà ‚ñà‚ñå
# ‚ñê‚ñõ ‚ñú‚ñå‚ñê‚ñõ ‚ñú‚ñå ‚ñê‚ñå  ‚ñê‚ñå‚ñà‚ñê‚ñå ‚ñò‚ñÑ‚ñü‚ñå ‚ñà‚ñò  ‚ñê‚ñõ  ‚ñò‚ñê‚ñõ ‚ñê‚ñå ‚ñà‚ññ‚ñà
# ‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñå ‚ñê‚ñå ‚ñê‚ñå  ‚ñê‚ñå‚ñà‚ñê‚ñå‚ñó‚ñà‚ñÄ‚ñú‚ñå ‚ñà   ‚ñê‚ñå   ‚ñê‚ñå ‚ñê‚ñå ‚ñê‚ñà‚ñõ
# ‚ñù‚ñà‚ñÑ‚ñà‚ñå‚ñù‚ñà‚ñÑ‚ñà‚ñò ‚ñê‚ñô‚ñÑ ‚ñê‚ñå‚ñà‚ñê‚ñå‚ñê‚ñô‚ñÑ‚ñà‚ñå ‚ñà   ‚ñù‚ñà‚ñÑ‚ñÑ‚ñå‚ñê‚ñå ‚ñê‚ñå  ‚ñà‚ñå
#  ‚ñù‚ñÄ‚ñù‚ñò ‚ñù‚ñÄ‚ñò   ‚ñÄ‚ñÄ ‚ñù‚ñò‚ñÄ‚ñù‚ñò ‚ñÄ‚ñÄ‚ñù‚ñò ‚ñÄ    ‚ñù‚ñÄ‚ñÄ ‚ñù‚ñò ‚ñù‚ñò  ‚ñà
#                                          ‚ñà‚ñå
#   Autor   -   Roberto Flores
#   Repo    -   https://github.com/25ASAB015/dotmarchy
#   √öltima actualizaci√≥n - 12-nov-2025
#
#   dotmarchy - Script automatizado para instalar y configurar dotfiles
#   en Arch Linux / Omarchy Linux con soporte multi-fuente de paquetes
#
# 	Copyright (C) 2025 dotmarchy <25ASAB015@ujmd.edu.sv>
# 	Licenciado bajo GPL-3.0

# 	√çndice r√°pido de secciones:
#  	1) Apariencia y opciones (colores, flags: --extras, --setup-env, --repo, rutas)
#  	2) Logging y utilidades (log, info, debug, tiempo)
#  	3) Encabezado visual (logo ASCII)
#  	4) Manejo de errores (log_error, trap)
#  	5) Utilidades internas (run, require_cmd, normalize_repo_url, is_installed)
#  	6) Argumentos CLI (parseo de flags)
#  	7) Interacci√≥n con usuario (welcome con detecci√≥n de modos)
#  	8) Dependencias:
#  	   - Configuraci√≥n del repositorio Chaotic-AUR
#  	   - Instalaci√≥n desde repositorios oficiales (pacman)
#  	   - Instalaci√≥n desde Chaotic-AUR (paru pre-compilado)
#  	   - Instalaci√≥n desde AUR (compilaci√≥n con paru)
#  	   - Instalaci√≥n de paquetes npm globales (solo con --extras)
#  	9) Configuraci√≥n del entorno de desarrollo (solo con --setup-env)
#  	   - Funciones helper: add_to_shell_config, clone_git_repo, download_script
#  	   - Lectura de archivo de configuraci√≥n: ~/.config/dotmarchy/setup.conf
#  	   - Creaci√≥n de directorios, clonado de repos, descarga de scripts
#  	10) dotbare (configuraci√≥n del gestor de dotfiles)
#  	11) Main (flujo principal de ejecuci√≥n)

# Caracter√≠sticas principales:
#   ‚úì Sistema de paquetes core + extras personalizable
#   ‚úì Instalaci√≥n desde 4 fuentes: pacman, Chaotic-AUR, AUR, npm
#   ‚úì Configuraci√≥n de entorno mediante archivo (~/.config/dotmarchy/setup.conf)
#   ‚úì Detecci√≥n inteligente de paquetes ya instalados
#   ‚úì Verificaci√≥n post-instalaci√≥n y logging de errores
#   ‚úì Respaldos autom√°ticos de configuraciones existentes
#   ‚úì Soporte SSH/HTTPS para repositorios de dotfiles
#   ‚úì Operaciones idempotentes (puede ejecutarse m√∫ltiples veces)

# Uso r√°pido:
#   dotmarchy                           # Instalaci√≥n b√°sica (paquetes core)
#   dotmarchy --extras                  # Instalaci√≥n completa (core + extras)
#   dotmarchy --setup-env               # Configurar entorno de desarrollo
#   dotmarchy --extras --setup-env      # Paquetes extras + configuraci√≥n de entorno
#   dotmarchy --repo URL                # Con repositorio personalizado
#   dotmarchy --help                    # Muestra ayuda completa

# Ejemplos:
#   dotmarchy
#   dotmarchy --extras
#   dotmarchy --setup-env
#   dotmarchy --extras --setup-env --repo git@github.com:usuario/dotfiles.git
#   dotmarchy --repo https://github.com/usuario/dotfiles.git
#   DRY_RUN=1 dotmarchy --extras       # Modo prueba (sin instalar)
#   VERBOSE=1 dotmarchy --extras       # Modo verbose (depuraci√≥n)
#==================================================

# Modo estricto: fallar ante errores y tuber√≠as rotas
set -Eeuo pipefail

#==================================================
# Apariencia (colores) y opciones
#==================================================

CRE=$(tput setaf 1 2>/dev/null || echo '') # Rojo
CYE=$(tput setaf 3 2>/dev/null || echo '') # Amarillo
CGR=$(tput setaf 2 2>/dev/null || echo '') # Verde
CBL=$(tput setaf 4 2>/dev/null || echo '') # Azul
BLD=$(tput bold 2>/dev/null || echo '')    # Negrita
CNC=$(tput sgr0 2>/dev/null || echo '')    # Restablecer colores

# Opciones por defecto
DRY_RUN=0
FORCE=0
VERBOSE=0
INSTALL_EXTRAS=0
SETUP_ENVIRONMENT=0
REPO_URL="git@github.com:25asab015/dotfiles.git"
DOTBARE_DIR_DEFAULT="$HOME/.cfg"
DOTBARE_TREE_DEFAULT="$HOME"

# Rutas de configuraci√≥n
SETUP_CONFIG="$HOME/.config/dotmarchy/setup.conf"

# Paquetes CORE (siempre se instalan)
CORE_DEPENDENCIES="tree bat highlight ruby-coderay git-delta diff-so-fancy npm"

# Paquetes extras por defecto (pueden ser sobrescritos por SETUP_CONFIG)
DEFAULT_EXTRA_DEPENDENCIES="neovim tmux htop ripgrep fd fzf"
DEFAULT_EXTRA_CHAOTIC_DEPENDENCIES="brave-bin visual-studio-code-bin"
DEFAULT_EXTRA_AUR_APPS="zsh-theme-powerlevel10k-git zsh-autosuggestions zsh-syntax-highlighting"
DEFAULT_EXTRA_NPM_PACKAGES="@fission-ai/openspec"

# Constantes y rutas
ERROR_LOG="$HOME/.local/share/dotmarchy/install_errors.log" # Log de errores
mkdir -p "$(dirname "$ERROR_LOG")" 2>/dev/null || true      # Asegurar carpeta

#==================================================
# Logging y utilidades b√°sicas
#==================================================

# Salida simple (aprovecha colores definidos m√°s abajo)
log() {
	printf "%s\n" "$*"
}

info() {
	printf "%b%s%b\n" "${CBL}" "$*" "${CNC}"
}

warn() {
	printf "%b%s%b\n" "${CYE}${BLD}" "$*" "${CNC}"
}

step() {
	printf "%b¬ª%b %s\n" "${BLD}${CBL}" "${CNC}" "$*"
}

# Mensajes de depuraci√≥n controlados por VERBOSE
debug() {
	[ "${VERBOSE:-0}" -eq 1 ] && printf "%b‚Ä¶ %s%b\n" "${BLD}" "$*" "${CNC}" || true
}

# Tiempo en milisegundos
now_ms() { date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)); }

# Formatear duraci√≥n ms ‚Üí legible
fmt_ms() {
	ms=${1:-0}
	if [ "$ms" -ge 1000 ]; then
		s=$((ms / 1000))
		t=$(((ms % 1000) / 100))
		printf "%d.%ds" "$s" "$t"
	else
		printf "%dms" "$ms"
	fi
}

#==================================================
# Logo
#==================================================
logo() {
	text="$1"
	printf "%b" "
   ‚ñó‚ññ                              ‚ñó‚ññ        
   ‚ñê‚ñå      ‚ñê‚ñå                      ‚ñê‚ñå        
 ‚ñü‚ñà‚ñü‚ñå ‚ñü‚ñà‚ñô ‚ñê‚ñà‚ñà‚ñà ‚ñê‚ñà‚ñô‚ñà‚ññ ‚ñü‚ñà‚ñà‚ññ ‚ñà‚ñü‚ñà‚ñå ‚ñü‚ñà‚ñà‚ññ‚ñê‚ñô‚ñà‚ñà‚ññ‚ñù‚ñà ‚ñà‚ñå
‚ñê‚ñõ ‚ñú‚ñå‚ñê‚ñõ ‚ñú‚ñå ‚ñê‚ñå  ‚ñê‚ñå‚ñà‚ñê‚ñå ‚ñò‚ñÑ‚ñü‚ñå ‚ñà‚ñò  ‚ñê‚ñõ  ‚ñò‚ñê‚ñõ ‚ñê‚ñå ‚ñà‚ññ‚ñà 
‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñå ‚ñê‚ñå ‚ñê‚ñå  ‚ñê‚ñå‚ñà‚ñê‚ñå‚ñó‚ñà‚ñÄ‚ñú‚ñå ‚ñà   ‚ñê‚ñå   ‚ñê‚ñå ‚ñê‚ñå ‚ñê‚ñà‚ñõ 
‚ñù‚ñà‚ñÑ‚ñà‚ñå‚ñù‚ñà‚ñÑ‚ñà‚ñò ‚ñê‚ñô‚ñÑ ‚ñê‚ñå‚ñà‚ñê‚ñå‚ñê‚ñô‚ñÑ‚ñà‚ñå ‚ñà   ‚ñù‚ñà‚ñÑ‚ñÑ‚ñå‚ñê‚ñå ‚ñê‚ñå  ‚ñà‚ñå 
 ‚ñù‚ñÄ‚ñù‚ñò ‚ñù‚ñÄ‚ñò   ‚ñÄ‚ñÄ ‚ñù‚ñò‚ñÄ‚ñù‚ñò ‚ñÄ‚ñÄ‚ñù‚ñò ‚ñÄ    ‚ñù‚ñÄ‚ñÄ ‚ñù‚ñò ‚ñù‚ñò  ‚ñà  
                                         ‚ñà‚ñå  

   ${BLD}${CRE}[ ${CYE}${text} ${CRE}]${CNC}\n\n"
}

#==================================================
# Manejo de errores
#==================================================
log_error() {
	error_msg=$1
	timestamp=$(date +"%Y-%m-%d %H:%M:%S")

	printf "%s" "[${timestamp}] ERROR: ${error_msg}\n" >>"$ERROR_LOG"
	printf "%s%sERROR:%s %s\n" "${CRE}" "${BLD}" "${CNC}" "${error_msg}" >&2
}

# Handler de error y activaci√≥n del trap
on_error() {
	exit_code=$?
	line=${BASH_LINENO[0]:-UNKNOWN}
	log_error "Fallo en la l√≠nea ${line}. C√≥digo: ${exit_code}"
	exit "$exit_code"
}
trap on_error ERR

#==================================================
# Verificaciones iniciales
#==================================================
initial_checks() {
	# Verificar que NO se ejecute como root
	if [ "$(id -u)" = 0 ]; then
		log_error "This script MUST NOT be run as root user."
		exit 1
	fi

	# Verificar que se ejecute desde $HOME (evita confusiones de ruta)
	if [ "$PWD" != "$HOME" ]; then
		log_error "The script must be executed from HOME directory."
		exit 1
	fi

	# Verificar conexi√≥n a internet (ping r√°pido a 8.8.8.8)
	if ! ping -q -c 1 -W 1 8.8.8.8 >/dev/null 2>&1; then
		log_error "No internet connection detected."
		exit 1
	fi

	# Verificar que el sistema es Arch/Manjaro (requiere pacman)
	if ! command -v pacman >/dev/null 2>&1; then
		log_error "Este script est√° pensado para Arch/Manjaro (requiere pacman)."
		exit 1
	fi
}

#==================================================
# Utilidades internas (helpers generales)
#==================================================

# Ejecuta un comando con descripci√≥n y cronometraje (respeta DRY_RUN)
run() {
	desc="$1"
	shift
	step "$desc"
	debug "Comando: $*"
	if [ "$DRY_RUN" -eq 1 ]; then
		log "   ‚Ü≥ (dry-run) $*"
		return 0
	fi
	start=$(now_ms)
	"$@"
	end=$(now_ms)
	dur=$((end - start))
	log "   ‚Ü≥ ‚úî Hecho en $(fmt_ms "$dur")"
}

# Verifica que un comando exista; si falta, aborta con c√≥digo 127
require_cmd() {
	name="$1"
	command -v "$name" >/dev/null 2>&1 || {
		log_error "No se encontr√≥ el comando requerido: $name"
		exit 127
	}
}

# Normaliza URL de repo a forma comparable (host/owner/repo)
normalize_repo_url() {
	# Entrada: URL (ssh o https); Salida: host/owner/repo en min√∫sculas, sin .git
	url="$1"
	url=${url%%.git}
	# ssh: git@github.com:owner/repo
	if [[ "$url" =~ ^git@([^:]+):(.+)$ ]]; then
		echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}" | tr '[:upper:]' '[:lower:]'
		return 0
	fi
	# https: https://github.com/owner/repo
	if [[ "$url" =~ ^https?://([^/]+)/(.+)$ ]]; then
		echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}" | tr '[:upper:]' '[:lower:]'
		return 0
	fi
	# Si ya es host/owner/repo
	echo "$url" | tr '[:upper:]' '[:lower:]'
}

# Convierte URL SSH a HTTPS
ssh_to_https() {
	url="$1"
	# ssh: git@github.com:owner/repo -> https://github.com/owner/repo
	if [[ "$url" =~ ^git@([^:]+):(.+)$ ]]; then
		host="${BASH_REMATCH[1]}"
		path="${BASH_REMATCH[2]}"
		# Si no termina en .git, agregarlo
		[[ "$path" =~ \.git$ ]] || path="${path}.git"
		echo "https://${host}/${path}"
		return 0
	fi
	# Si ya es HTTPS, devolverla tal cual
	echo "$url"
}

# Verifica si SSH est√° disponible para GitHub
check_ssh_auth() {
	# Intenta una conexi√≥n SSH a GitHub (timeout corto para no bloquear)
	# GitHub responde con "Hi username! You've successfully authenticated" si funciona
	# o "Permission denied" si no hay autenticaci√≥n
	ssh_output=$(ssh -T -o ConnectTimeout=5 -o StrictHostKeyChecking=no git@github.com 2>&1)
	ssh_exit=$?
	
	# Si la salida contiene "successfully authenticated", SSH est√° configurado
	if echo "$ssh_output" | grep -qi "successfully authenticated"; then
		return 0
	fi
	
	# Si el c√≥digo de salida es 1 y contiene "Permission denied", no hay autenticaci√≥n
	if [ "$ssh_exit" -eq 1 ] && echo "$ssh_output" | grep -qi "permission denied\|publickey"; then
		return 1
	fi
	
	# Otros errores (timeout, red, etc.) - asumir que no hay SSH disponible
	return 1
}

#==================================================
# Argumentos CLI (parseo de flags)
#==================================================

# Muestra ayuda breve de uso
usage() {
	cat <<EOF
Uso: $(basename "$0") [opciones] [REPO_URL]

Opciones:
  --repo URL      Especifica el repositorio de dotfiles a usar
  --extras        Instala paquetes adicionales opcionales adem√°s de los core
  --setup-env     Configura entorno de desarrollo (directorios, repos, scripts)
  -h, --help      Muestra esta ayuda y sale

Posicional:
  REPO_URL        Alternativamente puedes pasar la URL del repo como primer argumento

Archivo de configuraci√≥n:
  ~/.config/dotmarchy/setup.conf   Define configuraci√≥n para --setup-env

Ejemplos:
  $(basename "$0") --repo https://github.com/yo/mis-dotfiles.git
  $(basename "$0") git@github.com:yo/mis-dotfiles.git
  $(basename "$0") --extras
  $(basename "$0") --extras --setup-env
EOF
}

# Parsea opciones de l√≠nea de comandos
parse_args() {
	while [ $# -gt 0 ]; do
		case "$1" in
		--repo)
			shift || true
			REPO_URL="${1:-$REPO_URL}"
			;;
		--extras)
			INSTALL_EXTRAS=1
			;;
		--setup-env)
			SETUP_ENVIRONMENT=1
			;;
		-h | --help)
			usage
			exit 0
			;;
		-*)
			log_error "Opci√≥n desconocida: $1"
			usage
			exit 2
			;;
		*)
			# Argumento posicional: URL del repo
			REPO_URL="$1"
			;;
		esac
		shift || true
	done
}

# Comprueba si un paquete est√° instalado v√≠a pacman -Qq
is_installed() {
	pacman -Qq "$1" >/dev/null 2>&1
}

#==================================================
# Interacci√≥n con el usuario (bienvenida)
#==================================================

# Mensaje de bienvenida y confirmaci√≥n de continuaci√≥n
welcome() {
	clear 2>/dev/null || true
	logo "Bienvenido a dotmarchy, $USER"

	# Encabezado principal
	printf "%b" "${BLD}${CGR}Este script instalar√° y configurar√° tus dotfiles de forma segura y automatizada.${CNC}

"

	# ===== SECCI√ìN 1: OPERACIONES B√ÅSICAS (siempre se ejecutan) =====
	local core_count=$(echo "$CORE_DEPENDENCIES" | wc -w)
	
	printf "%b" "${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}
${BLD}${CBL}  OPERACIONES B√ÅSICAS ${CGR}(se ejecutar√°n siempre)${CNC}
${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}

  ${CGR}‚úì${CNC} Actualizaci√≥n del sistema con ${BLD}pacman -Syu${CNC}
  ${CGR}‚úì${CNC} Configuraci√≥n del repositorio ${BLD}Chaotic-AUR${CNC}
  ${CGR}‚úì${CNC} Instalaci√≥n de paquetes CORE (${CYE}${core_count}${CNC} paquetes):
      ${BLD}‚Üí${CNC} ${CYE}${CORE_DEPENDENCIES}${CNC}
  ${CGR}‚úì${CNC} Configuraci√≥n de ${BLD}dotbare${CNC} para gesti√≥n de dotfiles
  ${CGR}‚úì${CNC} Clonado de repositorio: ${BLD}${CBL}$(basename "$REPO_URL" .git)${CNC}
  ${CGR}‚úì${CNC} Respaldos autom√°ticos de configuraciones existentes

"

	# ===== SECCI√ìN 2: PAQUETES EXTRAS (opcional) =====
	if [ "$INSTALL_EXTRAS" -eq 1 ]; then
		# Cargar configuraci√≥n para obtener paquetes reales que se instalar√°n
		local extra_dependencies="$DEFAULT_EXTRA_DEPENDENCIES"
		local extra_chaotic_dependencies="$DEFAULT_EXTRA_CHAOTIC_DEPENDENCIES"
		local extra_aur_apps="$DEFAULT_EXTRA_AUR_APPS"
		local extra_npm_packages="$DEFAULT_EXTRA_NPM_PACKAGES"
		
		if [ -f "$SETUP_CONFIG" ]; then
			# shellcheck source=/dev/null
			source "$SETUP_CONFIG" 2>/dev/null || true
			[ -n "${EXTRA_DEPENDENCIES:-}" ] && extra_dependencies="$EXTRA_DEPENDENCIES"
			[ -n "${EXTRA_CHAOTIC_DEPENDENCIES:-}" ] && extra_chaotic_dependencies="$EXTRA_CHAOTIC_DEPENDENCIES"
			[ -n "${EXTRA_AUR_APPS:-}" ] && extra_aur_apps="$EXTRA_AUR_APPS"
			[ -n "${EXTRA_NPM_PACKAGES:-}" ] && extra_npm_packages="$EXTRA_NPM_PACKAGES"
		fi
		
		# Contar paquetes reales
		local dev_count=$(echo "$extra_dependencies" | wc -w)
		local chaotic_count=$(echo "$extra_chaotic_dependencies" | wc -w)
		local aur_count=$(echo "$extra_aur_apps" | wc -w)
		local npm_count=$(echo "$extra_npm_packages" | wc -w)
		local total_extras=$((dev_count + chaotic_count + aur_count + npm_count))
		
		printf "%b" "${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}
${BLD}${CBL}  PAQUETES EXTRAS ${CGR}(--extras ACTIVADO ‚úì)${CNC}
${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}

  ${CGR}‚úì${CNC} ${BLD}Total de paquetes extras a instalar: ${CYE}$total_extras${CNC}

"
		
		if [ "$dev_count" -gt 0 ]; then
			printf "%b" "  ${CGR}‚úì${CNC} Paquetes desde repositorios oficiales (${CYE}$dev_count${CNC}):
      ${BLD}‚Üí${CNC} ${CYE}$extra_dependencies${CNC}
"
		fi
		
		if [ "$chaotic_count" -gt 0 ]; then
			printf "%b" "  ${CGR}‚úì${CNC} Paquetes desde Chaotic-AUR (${CYE}$chaotic_count${CNC}):
      ${BLD}‚Üí${CNC} ${CYE}$extra_chaotic_dependencies${CNC}
"
		fi
		
		if [ "$aur_count" -gt 0 ]; then
			printf "%b" "  ${CGR}‚úì${CNC} Paquetes desde AUR (${CYE}$aur_count${CNC}):
      ${BLD}‚Üí${CNC} ${CYE}$extra_aur_apps${CNC}
"
		fi
		
		if [ "$npm_count" -gt 0 ]; then
			printf "%b" "  ${CGR}‚úì${CNC} Paquetes globales de npm (${CYE}$npm_count${CNC}):
      ${BLD}‚Üí${CNC} ${CYE}$extra_npm_packages${CNC}
"
		fi
		
		printf "%b" "
  ${CBL}‚Ñπ${CNC}  Personaliza estos paquetes en: ${CBL}${SETUP_CONFIG}${CNC}

"
	else
		printf "%b" "${BLD}${CYE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}
${BLD}${CYE}  PAQUETES EXTRAS ${CRE}(--extras NO activado ‚úó)${CNC}
${BLD}${CYE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}

  ${CYE}‚ö†${CNC}  Solo se instalar√°n los ${core_count} paquetes CORE b√°sicos.
  
  ${CGR}üí° Activa --extras para instalar paquetes adicionales desde:${CNC}
      ${BLD}‚Üí${CNC} Repositorios oficiales (pacman)
      ${BLD}‚Üí${CNC} Chaotic-AUR (binarios precompilados)
      ${BLD}‚Üí${CNC} AUR (compilaci√≥n local)
      ${BLD}‚Üí${CNC} npm (paquetes globales)

  ${BLD}Uso:${CNC} ${CYE}dotmarchy --extras${CNC}
  ${BLD}Personaliza:${CNC} ${CBL}${SETUP_CONFIG}${CNC}

"
	fi

	# ===== SECCI√ìN 3: CONFIGURACI√ìN DE ENTORNO (opcional) =====
	if [ "$SETUP_ENVIRONMENT" -eq 1 ]; then
		# Contar elementos desde el archivo de configuraci√≥n si existe
		local dir_count=0
		local repo_count=0
		local script_count=0
		local shell_count=0
		
		if [ -f "$SETUP_CONFIG" ]; then
			# shellcheck source=/dev/null
			source "$SETUP_CONFIG" 2>/dev/null || true
			dir_count=${#DIRECTORIES[@]}
			repo_count=${#GIT_REPOS[@]}
			script_count=${#SCRIPTS[@]}
			shell_count=${#SHELL_LINES[@]}
		fi
		
		printf "%b" "${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}
${BLD}${CBL}  CONFIGURACI√ìN DE ENTORNO ${CGR}(--setup-env ACTIVADO ‚úì)${CNC}
${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}

"
		if [ -f "$SETUP_CONFIG" ] && [ $((dir_count + repo_count + script_count + shell_count)) -gt 0 ]; then
			printf "%b" "  ${CGR}‚úì${CNC} Configuraci√≥n cargada desde: ${CBL}$SETUP_CONFIG${CNC}
      ${BLD}‚Üí${CNC} ${CYE}$dir_count${CNC} directorios a crear
      ${BLD}‚Üí${CNC} ${CYE}$repo_count${CNC} repositorios Git a clonar
      ${BLD}‚Üí${CNC} ${CYE}$script_count${CNC} scripts a descargar
      ${BLD}‚Üí${CNC} ${CYE}$shell_count${CNC} l√≠neas a agregar a la shell config

"
		else
			printf "%b" "  ${CYE}‚ö†${CNC}  Archivo de configuraci√≥n no encontrado o vac√≠o
  ${CBL}‚Ñπ${CNC}  Crea el archivo: ${CBL}${SETUP_CONFIG}${CNC}
  ${CBL}‚Ñπ${CNC}  Usa como plantilla: ${CBL}setup.conf.example${CNC}

"
		fi
	else
		printf "%b" "${BLD}${CYE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}
${BLD}${CYE}  CONFIGURACI√ìN DE ENTORNO ${CRE}(--setup-env NO activado ‚úó)${CNC}
${BLD}${CYE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}

  ${CYE}‚ö†${CNC}  No se configurar√° el entorno de desarrollo.
  
  ${CGR}üí° Activa --setup-env para:${CNC}
      ${BLD}‚Üí${CNC} Crear directorios de trabajo autom√°ticamente
      ${BLD}‚Üí${CNC} Clonar repositorios Git necesarios
      ${BLD}‚Üí${CNC} Descargar scripts y herramientas
      ${BLD}‚Üí${CNC} Configurar tu shell (.zshrc/.bashrc)

  ${BLD}Uso:${CNC} ${CYE}dotmarchy --setup-env${CNC}
  ${BLD}Config:${CNC} ${CBL}${SETUP_CONFIG}${CNC}

"
	fi

	# ===== SECCI√ìN 4: GARANT√çAS DE SEGURIDAD =====
	printf "%b" "${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}
${BLD}${CBL}  GARANT√çAS DE SEGURIDAD${CNC}
${BLD}${CBL}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${CNC}

  ${CGR}‚úì${CNC} NO requiere ni permite ejecuci√≥n como root
  ${CGR}‚úì${CNC} NO modifica configuraciones cr√≠ticas del sistema
  ${CGR}‚úì${CNC} Todos los cambios son reversibles (backups autom√°ticos)
  ${CGR}‚úì${CNC} Logging completo en: ${CBL}${ERROR_LOG}${CNC}

"

	# ===== PROMPT DE CONFIRMACI√ìN =====
	while :; do
		printf " %b" "${BLD}${CGR}¬øDeseas continuar con esta configuraci√≥n?${CNC} [s/N]: "
		read -r yn
		case "$yn" in
		[SsYy])
			break
			;;
		[Nn] | "")
			printf "\n%b\n" "${BLD}${CYE}Operaci√≥n cancelada${CNC}"
			exit 0
			;;
		*)
			printf "\n%b\n" "${BLD}${CRE}Error:${CNC} Digita '${BLD}${CYE}s/y${CNC}' para s√≠ o '${BLD}${CYE}n${CNC}' para no"
			;;
		esac
	done
}

#==================================================
# Dependencias (repositorios y paquetes)
#==================================================

# A√±ade el repositorio chaotic-aur (keyring, mirrorlist y entrada en pacman.conf)
add_chaotic_repo() {
	clear 2>/dev/null || true
	logo "Agregar el repositorio chaotic-aur"
	repo_name="chaotic-aur"
	key_id="3056513887B78AEB"
	sleep 2

	# Mensaje de configuraci√≥n del repositorio
	printf "%b\n" "${BLD}${CYE}Instalando el repositorio ${CBL}${repo_name}${CYE}...${CNC}"

	# Verificar si ya existe la secci√≥n en pacman.conf
	if grep -q "\[${repo_name}\]" /etc/pacman.conf; then
		printf "%b\n" "\n${BLD}${CYE}El repositorio ya existe en pacman.conf${CNC}"
		sleep 3
		return 0
	fi

	# Gesti√≥n de clave GPG
	if ! pacman-key -l | grep -q "$key_id"; then
		printf "%b\n" "${BLD}${CYE}Agregando la llave GPG...${CNC}"
		if ! sudo pacman-key --recv-key "$key_id" --keyserver keyserver.ubuntu.com 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			log_error "Error al recibir la llave GPG"
			return 1
		fi

		printf "%b\n" "${BLD}${CYE}Firmando la llave GPG localmente...${CNC}"
		if ! sudo pacman-key --lsign-key "$key_id" 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			log_error "Error al firmar la llave GPG"
			return 1
		fi
	else
		printf "\n%b\n" "${BLD}${CYE}La llave GPG ya existe en el keyring${CNC}"
	fi

	# Instalaci√≥n de paquetes requeridos
	chaotic_pkgs="chaotic-keyring chaotic-mirrorlist"
	for pkg in $chaotic_pkgs; do
		if ! pacman -Qq "$pkg" >/dev/null 2>&1; then
			printf "%b\n" "${BLD}${CYE}Instalando ${CBL}${pkg}${CNC}"
			if ! sudo pacman -U --noconfirm "https://cdn-mirror.chaotic.cx/chaotic-aur/${pkg}.pkg.tar.zst" 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
				log_error "Error al instalar ${pkg}"
				return 1
			fi
		else
			printf "%b\n" "${BLD}${CYE}${pkg} ya est√° instalado${CNC}"
		fi
	done

	# Agregar configuraci√≥n del repositorio
	printf "\n%b\n" "${BLD}${CYE}Agregando el repositorio a pacman.conf...${CNC}"
	if ! printf "\n[%s]\nInclude = /etc/pacman.d/chaotic-mirrorlist\n" "$repo_name" |
		sudo tee -a /etc/pacman.conf >/dev/null 2>>"$ERROR_LOG"; then
		log_error "Error al agregar la configuraci√≥n del repositorio"
		return 1
	fi

	printf "%b\n" "\n${BLD}${CBL}${repo_name} ${CGR}Repositorio configurado correctamente!${CNC}"
	sleep 3
}

#--------------------------------------------------
# Dependencias desde repos oficiales (pacman)
#--------------------------------------------------

install_dependencies() {
	clear 2>/dev/null || true
	logo "Instalando las dependencias necesarias desde los repositorios oficiales..."
	sleep 2

	# Verificar si reflector est√° instalado y actualizar el mirrorlist
	sudo pacman -Syy

	# Lista de dependencias (repos oficiales) - usar variable global CORE_DEPENDENCIES
	dependencies="$CORE_DEPENDENCIES"
	
	# Si --extras est√° activado, agregar paquetes extras
	if [ "$INSTALL_EXTRAS" -eq 1 ]; then
		# Cargar desde config o usar defaults
		local extra_deps=""
		if [ -f "$SETUP_CONFIG" ]; then
			# shellcheck source=/dev/null
			source "$SETUP_CONFIG"
			# Usar EXTRA_DEPENDENCIES del config o default
			extra_deps="${EXTRA_DEPENDENCIES[*]:-$DEFAULT_EXTRA_DEPENDENCIES}"
		else
			extra_deps="$DEFAULT_EXTRA_DEPENDENCIES"
		fi
		
		dependencies="$dependencies $extra_deps"
		printf "\n%b\n" "${BLD}${CYE}[--extras] Incluyendo paquetes adicionales opcionales${CNC}"
	fi

	printf "\n%b\n\n" "${BLD}${CBL}Verificando las dependencias necesarias...${CNC}"
	sleep 2

	# Detectar paquetes faltantes
	missing_pkgs=""
	for pkg in $dependencies; do
		if ! is_installed "$pkg"; then
			missing_pkgs="$missing_pkgs $pkg"
			printf "%b\n" " ${BLD}${CYE}$pkg ${CRE}no instalado${CNC}"
		else
			printf "%b\n" "${BLD}${CGR}$pkg ${CBL}ya est√° instalado${CNC}"
		fi
	done

	# Instalaci√≥n por lotes si es necesario
	if [ -n "$(printf "%s" "$missing_pkgs" | tr -s ' ')" ]; then
		count=$(printf "%s" "$missing_pkgs" | wc -w)
		printf "\n%b\n\n" "${BLD}${CYE}Instalando $count paquetes, por favor espera...${CNC}"

		if sudo pacman -S --noconfirm $missing_pkgs 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			# Verificar instalaci√≥n completa
			failed_pkgs=""
			for pkg in $missing_pkgs; do
				if ! is_installed "$pkg"; then
					failed_pkgs="$failed_pkgs $pkg"
					log_error "Error al instalar: $pkg"
				fi
			done

			# Mostrar resultados finales
			if [ -z "$(printf "%s" "$failed_pkgs" | tr -s ' ')" ]; then
				printf "%b\n\n" "${BLD}${CGR}Todos los paquetes se han instalado correctamente!${CNC}"
			else
				fail_count=$(printf "%s" "$failed_pkgs" | wc -w)
				printf "%b\n" "${BLD}${CRE}Error al instalar $fail_count paquetes:${CNC}"
				printf "%b\n\n" "  ${BLD}${CYE}$(printf "%s" "$failed_pkgs")${CNC}"
			fi
		else
			log_error "Error cr√≠tico durante la instalaci√≥n por lotes"
			printf "%b\n" "${BLD}${CRE}Error al instalar! Verifica el log para m√°s detalles${CNC}"
			return 1
		fi
	else
		printf "%b\n" "\n${BLD}${CGR}Todas las dependencias ya est√°n instaladas${CNC}"
	fi

	sleep 3
}

#--------------------------------------------------
# Dependencias desde chaotic (ej. paru)
#--------------------------------------------------

install_chaotic_dependencies() {
	clear 2>/dev/null || true
	logo "Instalando las dependencias necesarias desde el repositorio chaotic"
	sleep 2

	# Lista de dependencias (chaotic)
	chaotic_dependencies="paru"
	
	# Si --extras est√° activado, agregar paquetes extras
	if [ "$INSTALL_EXTRAS" -eq 1 ]; then
		# Cargar desde config o usar defaults
		local extra_chaotic=""
		if [ -f "$SETUP_CONFIG" ]; then
			# shellcheck source=/dev/null
			source "$SETUP_CONFIG"
			# Usar EXTRA_CHAOTIC_DEPENDENCIES del config o default
			extra_chaotic="${EXTRA_CHAOTIC_DEPENDENCIES[*]:-$DEFAULT_EXTRA_CHAOTIC_DEPENDENCIES}"
		else
			extra_chaotic="$DEFAULT_EXTRA_CHAOTIC_DEPENDENCIES"
		fi
		
		chaotic_dependencies="$chaotic_dependencies $extra_chaotic"
		printf "\n%b\n" "${BLD}${CYE}[--extras] Incluyendo paquetes adicionales opcionales desde Chaotic-AUR${CNC}"
	fi

	printf "%b\n\n" "${BLD}${CBL}Verificando las dependencias necesarias...${CNC}"
	sleep 2

	# Detectar paquetes faltantes
	missing_chaotic_pkgs=""
	for pkg in $chaotic_dependencies; do
		if ! is_installed "$pkg"; then
			missing_chaotic_pkgs="$missing_chaotic_pkgs $pkg"
			printf "%b\n" " ${BLD}${CYE}$pkg ${CRE}no instalado${CNC}"
		else
			printf "%b\n" "${BLD}${CGR}$pkg ${CBL}ya est√° instalado${CNC}"
		fi
	done

	# Instalaci√≥n por lotes si es necesario
	if [ -n "$(printf "%s" "$missing_chaotic_pkgs" | tr -s ' ')" ]; then
		count=$(printf "%s" "$missing_chaotic_pkgs" | wc -w)
		printf "\n%b\n\n" "${BLD}${CYE}Instalando $count paquetes, por favor espera...${CNC}"

		if sudo pacman -S --noconfirm $missing_chaotic_pkgs 2>&1 | tee -a "$ERROR_LOG" >/dev/null; then
			# Verificar instalaci√≥n completa
			failed_chaotic_pkgs=""
			for pkg in $missing_chaotic_pkgs; do
				if ! is_installed "$pkg"; then
					failed_chaotic_pkgs="$failed_chaotic_pkgs $pkg"
					log_error "Error al instalar: $pkg"
				fi
			done

			# Mostrar resultados finales
			if [ -z "$(printf "%s" "$failed_chaotic_pkgs" | tr -s ' ')" ]; then
				printf "%b\n\n" "${BLD}${CGR}Todos los paquetes se han instalado correctamente!${CNC}"
			else
				fail_count=$(printf "%s" "$failed_chaotic_pkgs" | wc -w)
				printf "%b\n" "${BLD}${CRE}Error al instalar $fail_count paquetes:${CNC}"
				printf "%b\n\n" "  ${BLD}${CYE}$(printf "%s" "$failed_chaotic_pkgs")${CNC}"
			fi
		else
			log_error "Error cr√≠tico durante la instalaci√≥n por lotes"
			printf "%b\n" "${BLD}${CRE}Error al instalar Verifica el log para m√°s detalles${CNC}"
			return 1
		fi
	else
		printf "\n%b\n" "${BLD}${CGR}Todas las dependencias ya est√°n instaladas!${CNC}"
	fi

	sleep 3
}

#--------------------------------------------------
# Dependencias desde AUR (extras)
#--------------------------------------------------

install_aur_dependencies() {
	clear 2>/dev/null || true
	logo "Instalando las dependencias necesarias desde AUR..."
	sleep 2

	# Lista de paquetes AUR adicionales
	aur_apps="dotbare"
	
	# Si --extras est√° activado, agregar paquetes extras
	if [ "$INSTALL_EXTRAS" -eq 1 ]; then
		# Cargar desde config o usar defaults
		local extra_aur=""
		if [ -f "$SETUP_CONFIG" ]; then
			# shellcheck source=/dev/null
			source "$SETUP_CONFIG"
			# Usar EXTRA_AUR_APPS del config o default
			extra_aur="${EXTRA_AUR_APPS[*]:-$DEFAULT_EXTRA_AUR_APPS}"
		else
			extra_aur="$DEFAULT_EXTRA_AUR_APPS"
		fi
		
		aur_apps="$aur_apps $extra_aur"
		printf "\n%b\n" "${BLD}${CYE}[--extras] Incluyendo paquetes adicionales opcionales desde AUR${CNC}"
	fi

	printf "%b\n\n" "${BLD}${CBL}Verificando las dependencias necesarias...${CNC}"
	sleep 2

	# Detectar paquetes faltantes AUR
	missing_aur=""
	for pkg in $aur_apps; do
		if ! is_installed "$pkg"; then
			missing_aur="$missing_aur $pkg"
			printf "%b\n" " ${BLD}${CYE}$pkg ${CRE}no instalado${CNC}"
		else
			printf "%b\n" "${BLD}${CGR}$pkg ${CBL}ya est√° instalado${CNC}"
		fi
	done

	# Instalaci√≥n por lotes AUR si es necesario
	if [ -n "$(printf "%s" "$missing_aur" | tr -s ' ')" ]; then
		count=$(printf "%s" "$missing_aur" | wc -w)
		printf "\n%b\n\n" "${BLD}${CYE}Instalando $count paquetes AUR, por favor espera...${CNC}"

		aur_failed=""
		for pkg in $missing_aur; do
			printf "%b\n" "${BLD}${CBL}Processing: ${pkg}${CNC}"

			if paru -S --skipreview --noconfirm "$pkg" >>"$ERROR_LOG" 2>&1; then
				printf "%b\n" "  ${BLD}${CGR}Se ha instalado correctamente!${CNC}"
			else
				log_error "Error al instalar el paquete AUR$pkg"
				aur_failed="$aur_failed $pkg"
				printf "%b\n" "  ${BLD}${CRE}Error al instalar${CNC}"
			fi
			sleep 0.5
		done

		# Mostrar resultados finales
		if [ -n "$(printf "%s" "$aur_failed" | tr -s ' ')" ]; then
			fail_count=$(printf "%s" "$aur_failed" | wc -w)
			printf "%b\n" "\n${BLD}${CRE}Error al instalar $fail_count/$count paquetes AUR:${CNC}"
			printf "%b\n\n" "${BLD}${CYE}$(printf "%s" "$aur_failed")${CNC}"
		else
			printf "\n%b\n\n" "${BLD}${CGR}Todos los paquetes AUR se han instalado correctamente!${CNC}"
		fi
	else
		printf "\n%b\n\n" "${BLD}${CGR}Todas las dependencias AUR ya est√°n instaladas!${CNC}"
	fi

	sleep 3
}

#--------------------------------------------------
# Dependencias desde NPM (paquetes globales)
#--------------------------------------------------

install_npm_dependencies() {
	# Solo ejecutar si --extras est√° activado
	if [ "$INSTALL_EXTRAS" -ne 1 ]; then
		return 0
	fi
	
	clear 2>/dev/null || true
	logo "Instalando paquetes npm globales..."
	sleep 2
	
	# Verificar que npm est√© instalado
	if ! command -v npm >/dev/null 2>&1; then
		log_error "npm no est√° instalado. No se pueden instalar paquetes npm."
		return 1
	fi

	# Cargar lista de paquetes npm desde config o usar defaults
	local npm_packages=""
	if [ -f "$SETUP_CONFIG" ]; then
		# shellcheck source=/dev/null
		source "$SETUP_CONFIG"
		# Usar EXTRA_NPM_PACKAGES del config o default
		npm_packages="${EXTRA_NPM_PACKAGES[*]:-$DEFAULT_EXTRA_NPM_PACKAGES}"
	else
		npm_packages="$DEFAULT_EXTRA_NPM_PACKAGES"
	fi
	
	printf "\n%b\n" "${BLD}${CYE}[--extras] Instalando paquetes npm globales...${CNC}"
	printf "%b\n\n" "${BLD}${CBL}Verificando paquetes npm...${CNC}"
	sleep 2

	# Detectar paquetes npm faltantes
	missing_npm=""
	for pkg in $npm_packages; do
		# Verificar si el paquete est√° instalado globalmente
		if npm list -g "$pkg" >/dev/null 2>&1; then
			printf "%b\n" "${BLD}${CGR}$pkg ${CBL}ya est√° instalado${CNC}"
		else
			missing_npm="$missing_npm $pkg"
			printf "%b\n" " ${BLD}${CYE}$pkg ${CRE}no instalado${CNC}"
		fi
	done

	# Instalaci√≥n de paquetes npm faltantes
	if [ -n "$(printf "%s" "$missing_npm" | tr -s ' ')" ]; then
		count=$(printf "%s" "$missing_npm" | wc -w)
		printf "\n%b\n\n" "${BLD}${CYE}Instalando $count paquetes npm, por favor espera...${CNC}"

		npm_failed=""
		for pkg in $missing_npm; do
			printf "%b\n" "${BLD}${CBL}Instalando: ${pkg}${CNC}"

			if npm install -g "$pkg" >>"$ERROR_LOG" 2>&1; then
				printf "%b\n" "  ${BLD}${CGR}Se ha instalado correctamente!${CNC}"
			else
				log_error "Error al instalar el paquete npm: $pkg"
				npm_failed="$npm_failed $pkg"
				printf "%b\n" "  ${BLD}${CRE}Error al instalar${CNC}"
			fi
			sleep 0.5
		done

		# Mostrar resultados finales
		if [ -n "$(printf "%s" "$npm_failed" | tr -s ' ')" ]; then
			fail_count=$(printf "%s" "$npm_failed" | wc -w)
			printf "%b\n" "\n${BLD}${CRE}Error al instalar $fail_count/$count paquetes npm:${CNC}"
			printf "%b\n\n" "${BLD}${CYE}$(printf "%s" "$npm_failed")${CNC}"
		else
			printf "\n%b\n\n" "${BLD}${CGR}Todos los paquetes npm se han instalado correctamente!${CNC}"
		fi
	else
		printf "\n%b\n\n" "${BLD}${CGR}Todos los paquetes npm ya est√°n instalados!${CNC}"
	fi

	sleep 3
}

#==================================================
# Configuraci√≥n del entorno de desarrollo
#==================================================

#--------------------------------------------------
# Funciones helper para configuraci√≥n de entorno
#--------------------------------------------------

# Agrega una l√≠nea al archivo de configuraci√≥n del shell de forma idempotente
add_to_shell_config() {
	local line="$1"
	local description="${2:-configuration}"
	local shell_rc=""
	
	# Detectar shell
	if [ -f ~/.zshrc ]; then
		shell_rc=~/.zshrc
	elif [ -f ~/.bashrc ]; then
		shell_rc=~/.bashrc
	else
		warn "No se encontr√≥ archivo de configuraci√≥n de shell (.zshrc o .bashrc)"
		return 1
	fi
	
	# Verificar si ya existe (b√∫squeda exacta)
	if grep -Fxq "$line" "$shell_rc"; then
		printf "  %b\n" "${CBL}‚úì${CNC} ${description} ${BLD}(ya configurado en $(basename "$shell_rc"))${CNC}"
		return 0
	fi
	
	# Agregar con comentario
	{
		echo ""
		echo "# Added by dotmarchy - $description"
		echo "$line"
	} >> "$shell_rc"
	
	printf "  %b\n" "${CGR}‚úì${CNC} Agregado ${BLD}${description}${CNC} a ${CBL}$(basename "$shell_rc")${CNC}"
	return 0
}

# Clona un repositorio git de forma segura (idempotente)
clone_git_repo() {
	local url="$1"
	local dest="$2"
	
	# Expandir ~ en el destino
	local expanded_dest="${dest/#\~/$HOME}"
	
	# Extraer nombre del repo para display
	local repo_name
	repo_name=$(basename "$url" .git)
	
	# Verificar si ya existe
	if [ -d "$expanded_dest" ]; then
		printf "  %b\n" "${CBL}‚úì${CNC} ${BLD}${repo_name}${CNC} ‚Üí ${dest} ${BLD}(ya existe)${CNC}"
		return 0
	fi
	
	printf "  %b\n" "${CYE}‚Üí${CNC} Clonando ${BLD}${repo_name}${CNC} ‚Üí ${dest}..."
	if git clone "$url" "$expanded_dest" >>"$ERROR_LOG" 2>&1; then
		printf "    %b\n" "${CGR}‚úì Clonado exitosamente${CNC}"
		return 0
	else
		log_error "Error al clonar $url a $expanded_dest"
		printf "    %b\n" "${CRE}‚úó Error al clonar${CNC}"
		return 1
	fi
}

# Descarga un script de forma segura (idempotente)
download_script() {
	local url="$1"
	local dest="$2"
	
	# Expandir ~ en el destino
	local expanded_dest="${dest/#\~/$HOME}"
	
	# Extraer nombre del script
	local script_name
	script_name=$(basename "$dest")
	
	# Crear directorio padre si no existe
	mkdir -p "$(dirname "$expanded_dest")"
	
	# Verificar si ya existe
	if [ -f "$expanded_dest" ]; then
		printf "  %b\n" "${CBL}‚úì${CNC} ${BLD}${script_name}${CNC} ‚Üí ${dest} ${BLD}(ya existe)${CNC}"
		return 0
	fi
	
	printf "  %b\n" "${CYE}‚Üí${CNC} Descargando ${BLD}${script_name}${CNC} ‚Üí ${dest}..."
	if curl -sL "$url" > "$expanded_dest" 2>>"$ERROR_LOG"; then
		chmod +x "$expanded_dest"
		printf "    %b\n" "${CGR}‚úì Descargado y hecho ejecutable${CNC}"
		return 0
	else
		log_error "Error al descargar $url a $expanded_dest"
		printf "    %b\n" "${CRE}‚úó Error al descargar${CNC}"
		return 1
	fi
}

# Crea directorios de forma segura
create_directories() {
	local dirs=("$@")
	local dir
	local created=0
	local existed=0
	
	for dir in "${dirs[@]}"; do
		# Expandir ~ en el path
		local expanded_dir="${dir/#\~/$HOME}"
		
		if [ -d "$expanded_dir" ]; then
			printf "  %b\n" "${CBL}‚úì${CNC} ${dir} ${BLD}(ya existe)${CNC}"
			: $((existed++))
		else
			if mkdir -p "$expanded_dir" 2>>"$ERROR_LOG"; then
				printf "  %b\n" "${CGR}‚úì${CNC} ${BLD}${dir}${CNC} ${CGR}(creado)${CNC}"
				: $((created++))
			else
				log_error "Error al crear directorio: $expanded_dir"
				printf "  %b\n" "${CRE}‚úó${CNC} ${dir} ${CRE}(error)${CNC}"
			fi
		fi
	done
	
	# Resumen
	if [ $created -gt 0 ] || [ $existed -gt 0 ]; then
		printf "\n"
		[ $created -gt 0 ] && info "  ‚Üí $created directorio(s) creado(s)"
		[ $existed -gt 0 ] && info "  ‚Üí $existed directorio(s) ya exist√≠a(n)"
	fi
}

#--------------------------------------------------
# Funci√≥n principal de configuraci√≥n del entorno
#--------------------------------------------------

setup_development_environment() {
	# Solo ejecutar si --setup-env est√° activado
	if [ "$SETUP_ENVIRONMENT" -ne 1 ]; then
		return 0
	fi
	
	clear 2>/dev/null || true
	logo "Configurando entorno de desarrollo"
	sleep 2
	
	printf "\n%b\n" "${BLD}${CYE}[--setup-env] Configurando entorno personalizado...${CNC}"
	
	# Verificar si existe el archivo de configuraci√≥n
	if [ ! -f "$SETUP_CONFIG" ]; then
		warn "Archivo de configuraci√≥n no encontrado: $SETUP_CONFIG"
		info "Ejecuta el script sin configuraci√≥n o crea el archivo de configuraci√≥n."
		info "Ejemplo de configuraci√≥n en: https://github.com/25ASAB015/dotmarchy"
		sleep 3
		return 0
	fi
	
	printf "%b\n\n" "${BLD}${CBL}Cargando configuraci√≥n desde $SETUP_CONFIG...${CNC}"
	
	# Cargar configuraci√≥n (source del archivo)
	# shellcheck source=/dev/null
	source "$SETUP_CONFIG"
	
	# 1. Crear directorios
	if [ "${#DIRECTORIES[@]}" -gt 0 ]; then
		printf "\n%b\n" "${BLD}${CGR}[${CYE}1${CGR}]${CNC} ${BLD}Creando estructura de directorios (${#DIRECTORIES[@]} total)...${CNC}\n"
		create_directories "${DIRECTORIES[@]}"
	fi
	
	# 2. Clonar repositorios git
	if [ "${#GIT_REPOS[@]}" -gt 0 ]; then
		printf "\n%b\n" "${BLD}${CGR}[${CYE}2${CGR}]${CNC} ${BLD}Clonando repositorios (${#GIT_REPOS[@]} total)...${CNC}"
		local cloned=0
		local skipped=0
		for entry in "${GIT_REPOS[@]}"; do
			# Buscar el √∫ltimo : antes de ~/ o / para dividir URL:DEST correctamente
			# Esto maneja URLs con : (como https://)
			if [[ "$entry" =~ ^(.+):([~/].*)$ ]]; then
				url="${BASH_REMATCH[1]}"
				dest="${BASH_REMATCH[2]}"
				if clone_git_repo "$url" "$dest"; then
					if [ -d "${dest/#\~/$HOME}/.git" ] || [ -d "${dest/#\~/$HOME}" ]; then
						# Revisar si exist√≠a antes o se acaba de clonar
						:
					fi
				fi
			else
				warn "Formato inv√°lido en GIT_REPOS: $entry (esperado URL:DESTINO)"
			fi
		done
		printf "\n"
	fi
	
	# 3. Descargar scripts
	if [ "${#SCRIPTS[@]}" -gt 0 ]; then
		printf "\n%b\n" "${BLD}${CGR}[${CYE}3${CGR}]${CNC} ${BLD}Descargando scripts (${#SCRIPTS[@]} total)...${CNC}"
		for entry in "${SCRIPTS[@]}"; do
			# Buscar el √∫ltimo : antes de ~/ o / para dividir URL:DEST correctamente
			if [[ "$entry" =~ ^(.+):([~/].*)$ ]]; then
				url="${BASH_REMATCH[1]}"
				dest="${BASH_REMATCH[2]}"
				download_script "$url" "$dest"
			else
				warn "Formato inv√°lido en SCRIPTS: $entry (esperado URL:DESTINO)"
			fi
		done
		printf "\n"
	fi
	
	# 4. Configurar shell
	if [ "${#SHELL_LINES[@]}" -gt 0 ]; then
		printf "\n%b\n" "${BLD}${CGR}[${CYE}4${CGR}]${CNC} ${BLD}Configurando shell (${#SHELL_LINES[@]} l√≠nea(s))...${CNC}"
		for line in "${SHELL_LINES[@]}"; do
			add_to_shell_config "$line" "environment setup"
		done
		printf "\n"
	fi
	
	printf "\n%b\n\n" "${BLD}${CGR}‚úì Configuraci√≥n del entorno completada!${CNC}"
	info "Nota: Reinicia tu shell o ejecuta 'source ~/.zshrc' (o ~/.bashrc) para aplicar cambios."
	
	sleep 3
}

#==================================================
# Configuraci√≥n de dotbare (gesti√≥n de dotfiles)
#==================================================

# Configura dotbare (repo bare de dotfiles) y ajusta remoto si es necesario
configure_dotbare() {
	clear 2>/dev/null || true
	logo "Configurando dotbare"
	sleep 2

	printf "%b\n" "${BLD}${CBL}Preparando dotbare para gestionar tus dotfiles...${CNC}"
	sleep 1

	require_cmd dotbare

	# Permitir override por entorno
	DOTBARE_DIR="${DOTBARE_DIR:-$DOTBARE_DIR_DEFAULT}"
	DOTBARE_TREE="${DOTBARE_TREE:-$DOTBARE_TREE_DEFAULT}"
	export DOTBARE_DIR DOTBARE_TREE

	if [ -d "$DOTBARE_DIR" ]; then
		# Verificar remoto
		if git --git-dir="$DOTBARE_DIR" rev-parse --is-bare-repository >/dev/null 2>&1; then
			current=""
			target_nc=""
			current_nc=""
			current=$(git --git-dir="$DOTBARE_DIR" remote get-url origin 2>/dev/null || echo "")
			target_nc=$(normalize_repo_url "$REPO_URL")
			current_nc=$(normalize_repo_url "$current")
			if [ -n "$current" ] && [ "$current_nc" != "$target_nc" ]; then
				if [ "$FORCE" -eq 1 ]; then
					printf "%b\n" "${BLD}${CYE}Remoto distinto detectado (${CBL}$current${CYE}). Reemplazando por ${CBL}$REPO_URL${CYE} por --force${CNC}"
					if git --git-dir="$DOTBARE_DIR" remote set-url origin "$REPO_URL" 2>>"$ERROR_LOG"; then
						printf "%b\n" "${BLD}${CGR}Remoto actualizado correctamente!${CNC}"
					else
						log_error "Error al actualizar el remoto de dotbare"
						printf "%b\n" "${BLD}${CRE}Error al actualizar el remoto de dotbare${CNC}"
					fi
				else
					printf "%b\n" "${BLD}${CYE}Remoto existente distinto (${CBL}$current${CYE}). Se mantiene. Usa --force para cambiarlo.${CNC}"
				fi
			else
				printf "%b\n" "${BLD}${CGR}dotbare ya inicializado y remoto correcto.${CNC}"
			fi
		else
			printf "%b\n" "${BLD}${CRE}${DOTBARE_DIR} existe pero no parece un repo bare.${CNC}"
			if [ "$FORCE" -eq 1 ]; then
				printf "%b\n" "${BLD}${CYE}Moviendo directorio conflictivo a respaldo...${CNC}"
				if mv "$DOTBARE_DIR" "${DOTBARE_DIR}.bak_$(date +%s)" 2>>"$ERROR_LOG"; then
					printf "%b\n" "${BLD}${CGR}Respaldo realizado correctamente.${CNC}"
				else
					log_error "Error al respaldar el directorio conflictivo: $DOTBARE_DIR"
					printf "%b\n" "${BLD}${CRE}Error al respaldar el directorio conflictivo${CNC}"
					exit 1
				fi
			else
				printf "%b\n" "${BLD}${CRE}Directorio en conflicto. Usa --force para respaldar y continuar.${CNC}"
				exit 1
			fi
		fi
	fi

	if [ ! -d "$DOTBARE_DIR" ]; then
		printf "%b\n" "${BLD}${CBL}Inicializando dotbare con tu repositorio...${CNC}"
		
		# Determinar URL a usar (SSH o HTTPS)
		FINAL_REPO_URL="$REPO_URL"
		
		# Si la URL es SSH, verificar autenticaci√≥n
		if [[ "$REPO_URL" =~ ^git@ ]]; then
			if ! check_ssh_auth; then
				# No hay autenticaci√≥n SSH, convertir a HTTPS
				FINAL_REPO_URL=$(ssh_to_https "$REPO_URL")
				printf "%b\n" "${BLD}${CYE}SSH no disponible. Usando HTTPS: ${CBL}${FINAL_REPO_URL}${CNC}"
			else
				printf "%b\n" "${BLD}${CGR}Autenticaci√≥n SSH detectada. Usando SSH.${CNC}"
			fi
		fi
		
		# Intentar inicializar con la URL determinada
		if dotbare finit -u "$FINAL_REPO_URL" 2>>"$ERROR_LOG"; then
			printf "%b\n" "${BLD}${CGR}dotbare inicializado correctamente!${CNC}"
		else
			# Si fall√≥ y era SSH, intentar con HTTPS como fallback
			if [[ "$REPO_URL" =~ ^git@ ]] && [ "$FINAL_REPO_URL" = "$REPO_URL" ]; then
				HTTPS_URL=$(ssh_to_https "$REPO_URL")
				printf "%b\n" "${BLD}${CYE}Fall√≥ con SSH. Intentando con HTTPS: ${CBL}${HTTPS_URL}${CNC}"
				if dotbare finit -u "$HTTPS_URL" 2>>"$ERROR_LOG"; then
					FINAL_REPO_URL="$HTTPS_URL"
					printf "%b\n" "${BLD}${CGR}dotbare inicializado correctamente con HTTPS!${CNC}"
				else
					log_error "Error al inicializar dotbare (intent√≥ SSH y HTTPS)"
					printf "%b\n" "${BLD}${CRE}Error al inicializar dotbare${CNC}"
					printf "%b\n" "${BLD}${CYE}Verifica que el repositorio existe y es accesible.${CNC}"
					return 1
				fi
			else
				log_error "Error al inicializar dotbare"
				printf "%b\n" "${BLD}${CRE}Error al inicializar dotbare${CNC}"
				printf "%b\n" "${BLD}${CYE}Verifica que el repositorio existe y es accesible.${CNC}"
				return 1
			fi
		fi
	fi

	# Usar FINAL_REPO_URL si est√° definida, sino REPO_URL
	DISPLAY_URL="${FINAL_REPO_URL:-$REPO_URL}"
	printf "%b\n" "${BLD}${CGR}dotbare listo! (${CBL}${DOTBARE_DIR}${CGR} ‚Üî ${CBL}${DISPLAY_URL}${CGR})${CNC}"
	sleep 2
}

#==================================================
# Ejecuci√≥n principal (orden del flujo)
#==================================================


main() {
	# Procesar flags y argumento posicional (REPO_URL)
	parse_args "$@" # Analiza los argumentos de l√≠nea de comandos y flags (como --force, --dry-run, etc.)
	initial_checks  # Realiza comprobaciones iniciales: no root, en $HOME, dependencias b√°sicas, etc.
	welcome         # Muestra mensaje de bienvenida e informaci√≥n al usuario

	add_chaotic_repo             # A√±ade el repositorio Chaotic-AUR si es necesario (para instalar paquetes extra)
	install_dependencies         # Instala los paquetes requeridos desde los repositorios oficiales
	install_chaotic_dependencies # Instala dependencias espec√≠ficas desde Chaotic-AUR
	install_aur_dependencies     # Instala paquetes desde AUR usando un helper (ej: paru)
	install_npm_dependencies     # Instala paquetes npm globales (solo con --extras)

	configure_dotbare                 # Inicializa y configura dotbare con el repositorio de dotfiles indicado
	setup_development_environment     # Configura entorno de desarrollo (solo con --setup-env)
}

# Ejecuta el script
main "$@"
